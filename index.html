<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>スイカ割り Ver.9</title>
    <style>
        body { margin: 0; background: #fff; color: #000; font-family: sans-serif; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; bottom: 15px; left: 15px; pointer-events: none; z-index: 10; font-weight: bold; background: rgba(255, 255, 255, 0.7); padding: 5px; border-radius: 4px; }
        #controls { position: absolute; bottom: 15px; right: 15px; z-index: 20; }
        button { padding: 12px 20px; font-size: 14px; background: #333; color: white; border: 1px solid #000; border-radius: 5px; cursor: pointer; }
        .msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="mode-text">オープン</div>
        <div id="dist-text">歩数: 0 / 最短: --</div>
    </div>
    <div id="controls"><button id="toggleMode">表示/非表示</button></div>
    <div class="msg" id="start-msg">画面をタップして開始<br>(Ver.8.2)</div>
    <canvas id="gameCanvas"></canvas>

<script>
// --- サウンドデータ (短縮表記) ---
const dogAudioData1 = "data:audio/wav;base64,UklGRnoAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YVp6f39/f39/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgICAgH9/f39/f39/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgICA";
const dogAudioData2 = "data:audio/wav;base64,UklGRnoAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YVp6enp6enp6enp6enp6enp6enp6enp6enp6f39/f39/f39/f39/f39/f39/f39/f39/f39/enp6enp6enp6enp6enp6enp6enp6enp6enp6f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/";

let dogWarnSound = new Audio(dogAudioData1);
let gameOverSound = new Audio(dogAudioData2);
let audioCtx = null;
let soundReady = false;

// 解除の儀式：移動を邪魔しないよう「バックグラウンド」で実行
function unlockAudio() {
    if (soundReady) return;
    
    // 音量を0にして、エラーを無視して再生許可だけ取る
    dogWarnSound.volume = 0;
    gameOverSound.volume = 0;
    
    const silentPlay = () => {
        dogWarnSound.play().then(() => { dogWarnSound.pause(); dogWarnSound.volume = 1; });
        gameOverSound.play().then(() => { gameOverSound.pause(); gameOverSound.volume = 1; });
        if (audioCtx) audioCtx.resume();
        soundReady = true;
    };
    silentPlay();
}

function playCustomSound(audioObj) {
    if (!soundReady) return;
    audioObj.currentTime = 0;
    audioObj.play().catch(() => {}); // 失敗しても無視（フリーズ防止）
}

function playOsc(f, t, d, v = 0.05) {
    if (!audioCtx || audioCtx.state === 'suspended') {
        if (audioCtx) audioCtx.resume();
        if (!audioCtx || audioCtx.state === 'suspended') return;
    }
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t;
    o.frequency.setValueAtTime(f, audioCtx.currentTime);
    g.gain.setValueAtTime(v, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + d);
}

// --- ゲーム本体 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startMsg = document.getElementById('start-msg');
const modeText = document.getElementById('mode-text');
const distText = document.getElementById('dist-text');
const ROWS = 13, COLS = 13;

let map = [], player = { x: 1, y: 1 }, dog = { x: 0, y: 0 }, isBlind = false;
let currentSteps = 0, minDistance = 0, currentPitchIndex = 0, coinPositions = [];

function generateMaze() {
    map = Array.from({ length: ROWS }, () => Array(COLS).fill(1));
    let x = 1, y = 1; map[y][x] = 0;
    for(let i=0; i<80; i++) {
        let [dx, dy] = [[0,1],[0,-1],[1,0],[-1,0]][Math.floor(Math.random()*4)];
        if(x+dx>0 && x+dx<COLS-1 && y+dy>0 && y+dy<ROWS-1) { x+=dx; y+=dy; map[y][x]=0; }
    }
    dog = { x: COLS-2, y: ROWS-2 }; map[dog.y][dog.x] = 0;
    map[1][COLS-2] = 2; // スイカ
    minDistance = "??";
}

function movePlayer(dx, dy) {
    const nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS || map[ny][nx] === 1) {
        playOsc(150, 'square', 0.1);
    } else {
        player.x = nx; player.y = ny;
        currentSteps++;
        if (player.x === dog.x && player.y === dog.y) {
            playCustomSound(gameOverSound);
            setTimeout(() => { alert("噛まれた！"); initGame(); }, 100);
            return;
        }
        if (map[ny][nx] === 2) {
            playOsc(800, 'sine', 0.5);
            setTimeout(() => { alert("成功！"); initGame(); }, 100);
            return;
        }
        // 犬の警告音
        if (Math.abs(player.x - dog.x) + Math.abs(player.y - dog.y) === 1) {
            playCustomSound(dogWarnSound);
        }
    }
    distText.innerText = `歩数: ${currentSteps}`;
    draw();
}

function draw() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const s = Math.min(canvas.width/COLS, canvas.height/ROWS);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(!isBlind) {
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                if(map[y][x]===1) { ctx.fillStyle="#000"; ctx.fillRect(x*s,y*s,s,s); }
                if(map[y][x]===2) { ctx.fillStyle="#f00"; ctx.fillRect(x*s,y*s,s,s); }
            }
        }
        ctx.fillStyle='#2c2'; ctx.beginPath(); ctx.arc(dog.x*s+s/2, dog.y*s+s/2, s/4, 0, 7); ctx.fill();
        ctx.fillStyle='#07f'; ctx.beginPath(); ctx.arc(player.x*s+s/2, player.y*s+s/2, s/3, 0, 7); ctx.fill();
    } else {
        ctx.fillStyle="#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
    }
}

let tsX = null, tsY = null;
window.addEventListener('touchstart', e => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    unlockAudio(); // 非同期で実行（移動を止めない）
    startMsg.style.display = 'none';
    tsX = e.touches[0].clientX; tsY = e.touches[0].clientY;
}, { passive: false });

window.addEventListener('touchend', e => {
    if (tsX === null) return;
    const dx = e.changedTouches[0].clientX - tsX, dy = e.changedTouches[0].clientY - tsY;
    if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
        if (Math.abs(dx) > Math.abs(dy)) movePlayer(dx > 0 ? 1 : -1, 0); else movePlayer(0, dy > 0 ? 1 : -1);
    }
    tsX = null;
}, { passive: false });

document.getElementById('toggleMode').onclick = (e) => {
    isBlind = !isBlind; modeText.innerText = isBlind ? "ブラインド" : "オープン"; draw();
};

function initGame() { generateMaze(); player = {x:1, y:1}; currentSteps = 0; draw(); }
window.onload = initGame;
</script>
</body>
</html>
