<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>シンプル・スイカ割り (Ver.ios4.16)</title>
    <style>
        body { margin: 0; background: #fff; color: #000; font-family: sans-serif; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        #ui { 
            position: absolute; bottom: 15px; left: 15px; pointer-events: none; z-index: 10; font-weight: bold;
            line-height: 1.4; background: rgba(255, 255, 255, 0.7); padding: 5px; border-radius: 4px;
        }
        #controls { position: absolute; bottom: 15px; right: 15px; z-index: 20; }
        button { padding: 12px 20px; font-size: 14px; background: #333; color: white; border: 1px solid #000; border-radius: 5px; cursor: pointer; }
        .msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="mode-text">オープン</div>
        <div id="dist-text">歩数: 0 / 最短: --</div>
    </div>
    <div id="controls"><button id="toggleMode">表示/非表示</button></div>
    <div class="msg" id="start-msg">画面をタップして開始<br>（Ver.ios4.2aukinnsi）</div>
    <canvas id="gameCanvas"></canvas>

<script>
// ==========================================
// 1. サウンド設定 (Base64 + Web Audio API 方式)
// ==========================================
const dogAudioData1 = "data:audio/wav;base64,UklGRnoAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YVp6f39/f39/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgICAgH9/f39/f39/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgICA";
const dogAudioData2 = "data:audio/wav;base64,UklGRnoAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YVp6enp6enp6enp6enp6enp6enp6enp6enp6f39/f39/f39/f39/f39/f39/f39/f39/f39/enp6enp6enp6enp6enp6enp6enp6enp6enp6f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/";

let audioCtx = null;
let dogBuffer = null;
let gameOverBuffer = null;
let soundReady = false;
let isUnlocking = false;

// Base64データをAudioBufferに変換する
async function getBufferFromBase64(base64) {
    const response = await fetch(base64);
    const arrayBuffer = await response.arrayBuffer();
    return await audioCtx.decodeAudioData(arrayBuffer);
}

async function unlockAudio() {
    if (soundReady || isUnlocking) return;
    isUnlocking = true;
    
    try {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') await audioCtx.resume();

        // Base64から直接データを読み込む
        [dogBuffer, gameOverBuffer] = await Promise.all([
            getBufferFromBase64(dogAudioData1),
            getBufferFromBase64(dogAudioData2)
        ]);

        // iOSの再生許可を得るための無音信号
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        g.gain.value = 0;
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(0);
        o.stop(0.01);

        soundReady = true;
        console.log("Web Audio Unlocked with Base64");
    } catch(e) {
        console.error("Unlock failed", e);
    } finally {
        isUnlocking = false;
    }
}

function playBuffer(buffer) {
    if (!soundReady || !audioCtx || !buffer) return;
    
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    
    const gainNode = audioCtx.createGain();
    gainNode.gain.setValueAtTime(1.0, audioCtx.currentTime); // 音量を1.0に固定
    
    source.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    source.start(0);
}

async function playOscillator(f, t, d, v = 0.05) {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t;
    o.frequency.setValueAtTime(f, now);
    g.gain.setValueAtTime(v, now);
    g.gain.exponentialRampToValueAtTime(0.01, now + d);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(now);
    o.stop(now + d);
}

function checkDogSound() {
    let d = Math.abs(player.x - dog.x) + Math.abs(player.y - dog.y);
    if (d === 1) playBuffer(dogBuffer);
}

// ==========================================
// 2. ゲームロジック
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startMsg = document.getElementById('start-msg');
const modeText = document.getElementById('mode-text');
const distText = document.getElementById('dist-text');
const ROWS = 13, COLS = 13;

let map = [], player = { x: 1, y: 1 }, dog = { x: 0, y: 0 };
let isBlind = false;
let currentSteps = 0, minDistance = 0, currentPitchIndex = 0, coinPositions = [];

function generateSimpleMaze() {
    let found = false;
    while (!found) {
        map = Array.from({ length: ROWS }, () => Array(COLS).fill(1));
        let x = 1, y = 1; map[y][x] = 0;
        for(let i=0; i<75; i++) {
            let dirs = [[0,1],[0,-1],[1,0],[-1,0]];
            let [dx, dy] = dirs[Math.floor(Math.random()*4)];
            if(x+dx > 0 && x+dx < COLS-1 && y+dy > 0 && y+dy < ROWS-1) {
                x += dx; y += dy; map[y][x] = 0;
            }
        }
        let dists = Array.from({ length: ROWS }, () => Array(COLS).fill(-1));
        let parent = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        let q = [{x: 1, y: 1, d: 0}]; dists[1][1] = 0;
        let candidates = [];
        let allWalkable = [];
        while(q.length > 0) {
            let curr = q.shift();
            allWalkable.push(curr);
            if(curr.d >= 20 && curr.d <= 35) candidates.push(curr);
            for(let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                let nx = curr.x + dx, ny = curr.y + dy;
                if(map[ny][nx] === 0 && dists[ny][nx] === -1) {
                    dists[ny][nx] = curr.d + 1;
                    parent[ny][nx] = {x: curr.x, y: curr.y};
                    q.push({x: nx, y: ny, d: curr.d + 1});
                }
            }
        }
        if(candidates.length > 0) {
            let goal = candidates[Math.floor(Math.random()*candidates.length)];
            map[goal.y][goal.x] = 2;
            minDistance = goal.d;
            let shortestPathNodes = new Set();
            let pNode = goal;
            while(pNode) {
                shortestPathNodes.add(`${pNode.x},${pNode.y}`);
                pNode = parent[pNode.y][pNode.x];
            }
            let dogCandidates = allWalkable.filter(p => !shortestPathNodes.has(`${p.x},${p.y}`) && (p.x !== goal.x || p.y !== goal.y));
            if(dogCandidates.length === 0) continue; 
            dog = dogCandidates[Math.floor(Math.random() * dogCandidates.length)];
            coinPositions = [];
            let currC = parent[goal.y][goal.x];
            let tempPath = [];
            while(currC && (currC.x !== 1 || currC.y !== 1)) {
                tempPath.push({x: currC.x, y: currC.y});
                currC = parent[currC.y][currC.x];
            }
            tempPath.reverse(); 
            tempPath.forEach((p, index) => {
                if((index + 1) % 2 === 0) { 
                    map[p.y][p.x] = 3;
                    coinPositions.push({x: p.x, y: p.y, order: index});
                }
            });
            found = true;
        }
    }
}

function movePlayer(dx, dy) {
    if (isUnlocking || !soundReady) return;

    const nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS || map[ny][nx] === 1) {
        playOscillator(150, 'square', 0.1);
    } else {
        player.x = nx; player.y = ny;
        currentSteps++;
        if (player.x === dog.x && player.y === dog.y) {
            playBuffer(gameOverBuffer);
            setTimeout(() => { alert("緑のイヌに噛みつかれた！"); initGame(); }, 100);
            return;
        }
        if (map[ny][nx] === 2) {
            playOscillator(800, 'sine', 0.5);
            setTimeout(() => { alert(`成功！歩数: ${currentSteps}`); initGame(); }, 100);
            return;
        } else if (map[ny][nx] === 3) {
            const hitCoin = coinPositions.find(c => c.x === nx && c.y === ny);
            if (hitCoin) {
                const pitch = Math.min(800 + (currentPitchIndex * 50), 2000);
                playOscillator(pitch, 'sine', 0.15);
                currentPitchIndex++;
                coinPositions = coinPositions.filter(c => {
                    if (c.order <= hitCoin.order) { map[c.y][c.x] = 0; return false; }
                    return true;
                });
            }
        }
        checkDogSound();
    }
    distText.innerText = `歩数: ${currentSteps} / 最短: ${minDistance}`;
    draw();
}

function draw() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const size = Math.min(canvas.width / COLS, canvas.height / ROWS);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!isBlind) {
        ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                if (map[y][x] !== 1) {
                    if (y > 0 && map[y-1][x] === 1) { ctx.beginPath(); ctx.moveTo(x*size, y*size); ctx.lineTo((x+1)*size, y*size); ctx.stroke(); }
                    if (y < ROWS-1 && map[y+1][x] === 1) { ctx.beginPath(); ctx.moveTo(x*size, (y+1)*size); ctx.lineTo((x+1)*size, (y+1)*size); ctx.stroke(); }
                    if (x > 0 && map[y][x-1] === 1) { ctx.beginPath(); ctx.moveTo(x*size, y*size); ctx.lineTo(x*size, (y+1)*size); ctx.stroke(); }
                    if (x < COLS-1 && map[y][x+1] === 1) { ctx.beginPath(); ctx.moveTo((x+1)*size, y*size); ctx.lineTo((x+1)*size, (y+1)*size); ctx.stroke(); }
                    if (map[y][x] === 2) { ctx.fillStyle = "#f00"; ctx.fillRect(x*size + size*0.1, y*size + size*0.1, size*0.8, size*0.8); }
                    if (map[y][x] === 3) { ctx.fillStyle = "#ffd700"; ctx.beginPath(); ctx.arc(x*size + size/2, y*size + size/2, size/6, 0, Math.PI*2); ctx.fill(); }
                }
            }
        }
        ctx.fillStyle = '#22cc22'; ctx.beginPath(); ctx.arc(dog.x*size + size/2, dog.y*size + size/2, size/4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0077ff'; ctx.beginPath(); ctx.arc(player.x*size + size/2, player.y*size + size/2, size/3, 0, Math.PI*2); ctx.fill();
    } else {
        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

function initGame() {
    generateSimpleMaze();
    player = { x: 1, y: 1 };
    currentSteps = 0; currentPitchIndex = 0;
    distText.innerText = `歩数: 0 / 最短: ${minDistance}`;
    draw();
}

// ==========================================
// 3. イベント操作
// ==========================================
let tsX = null, tsY = null;

window.addEventListener('touchstart', async (e) => {
    if (e.touches.length > 1) e.preventDefault();

    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    if (!soundReady && !isUnlocking) {
        startMsg.innerText = "読込中...";
        await unlockAudio();
        startMsg.style.display = 'none';
        return; 
    }

    tsX = e.touches[0].clientX; 
    tsY = e.touches[0].clientY;
}, { passive: false });

window.addEventListener('touchend', e => {
    if (tsX === null || tsY === null) return;
    const dx = e.changedTouches[0].clientX - tsX, dy = e.changedTouches[0].clientY - tsY;
    if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
        if (Math.abs(dx) > Math.abs(dy)) movePlayer(dx > 0 ? 1 : -1, 0); else movePlayer(0, dy > 0 ? 1 : -1);
    }
    tsX = null; tsY = null;
}, { passive: false });

document.getElementById('toggleMode').onclick = (e) => {
    e.stopPropagation();
    isBlind = !isBlind; modeText.innerText = isBlind ? "ブラインド" : "視界あり"; draw();
};

window.onload = initGame;
window.onresize = draw;

</script>
</body>
</html>
