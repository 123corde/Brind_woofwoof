<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>スイカ割り (Ver.final-zero)</title>
    <style>
        body { margin: 0; background: #fff; color: #000; font-family: sans-serif; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; bottom: 15px; left: 15px; pointer-events: none; z-index: 10; font-weight: bold; background: rgba(255, 255, 255, 0.7); padding: 5px; border-radius: 4px; }
        #controls { position: absolute; bottom: 15px; right: 15px; z-index: 20; }
        button { padding: 12px 20px; font-size: 14px; background: #333; color: white; border: none; border-radius: 5px; }
        .msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; width: 100%; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="mode-text">オープン</div>
        <div id="dist-text">歩数: 0 / 最短: --</div>
    </div>
    <div id="controls"><button id="toggleMode">表示/非表示</button></div>
    <div class="msg" id="start-msg">画面をタップして開始</div>
    <canvas id="gameCanvas"></canvas>

<script>
// ==========================================
// 1. サウンド設定 (読み込み不要の合成方式)
// ==========================================
let audioCtx = null;
let soundReady = false;

// 犬の鳴き声を合成 (「ワン！」という短いノイズ)
function playDogSound() {
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const n = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    n.type = 'sawtooth';
    n.frequency.setValueAtTime(100, now);
    n.frequency.exponentialRampToValueAtTime(50, now + 0.1);
    g.gain.setValueAtTime(0.1, now);
    g.gain.linearRampToValueAtTime(0, now + 0.1);
    n.connect(g); g.connect(audioCtx.destination);
    n.start(); n.stop(now + 0.1);
}

// ゲームオーバー音を合成 (不協和音)
function playGameOverSound() {
    if (!audioCtx) return;
    [150, 160, 170].forEach(f => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.frequency.value = f;
        g.gain.setValueAtTime(0.1, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 1);
    });
}

// 共通の電子音 (壁・コイン)
async function playOscillator(f, t, d, v = 0.05) {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = t;
    o.frequency.setValueAtTime(f, now);
    g.gain.setValueAtTime(v, now);
    g.gain.exponentialRampToValueAtTime(0.01, now + d);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + d);
}

async function unlockAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    await audioCtx.resume();
    soundReady = true; // 読み込みがないので即OK
}

// ==========================================
// 2. ゲームロジック
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startMsg = document.getElementById('start-msg');
const modeText = document.getElementById('mode-text');
const distText = document.getElementById('dist-text');
const ROWS = 13, COLS = 13;

let map = [], player = { x: 1, y: 1 }, dog = { x: 0, y: 0 };
let isBlind = false;
let currentSteps = 0, minDistance = 0, currentPitchIndex = 0, coinPositions = [];

function generateSimpleMaze() {
    let found = false;
    while (!found) {
        map = Array.from({ length: ROWS }, () => Array(COLS).fill(1));
        let x = 1, y = 1; map[y][x] = 0;
        for(let i=0; i<75; i++) {
            let dirs = [[0,1],[0,-1],[1,0],[-1,0]];
            let [dx, dy] = dirs[Math.floor(Math.random()*4)];
            if(x+dx > 0 && x+dx < COLS-1 && y+dy > 0 && y+dy < ROWS-1) {
                x += dx; y += dy; map[y][x] = 0;
            }
        }
        let dists = Array.from({ length: ROWS }, () => Array(COLS).fill(-1));
        let q = [{x: 1, y: 1, d: 0}]; dists[1][1] = 0;
        let candidates = [], allWalkable = [];
        while(q.length > 0) {
            let curr = q.shift(); allWalkable.push(curr);
            if(curr.d >= 15) candidates.push(curr);
            for(let [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                let nx = curr.x + dx, ny = curr.y + dy;
                if(map[ny][nx] === 0 && dists[ny][nx] === -1) {
                    dists[ny][nx] = curr.d + 1;
                    q.push({x: nx, y: ny, d: curr.d + 1});
                }
            }
        }
        if(candidates.length > 0) {
            let goal = candidates[Math.floor(Math.random()*candidates.length)];
            map[goal.y][goal.x] = 2; minDistance = dists[goal.y][goal.x];
            dog = allWalkable[Math.floor(Math.random() * allWalkable.length)];
            found = true;
        }
    }
}

function movePlayer(dx, dy) {
    if (!soundReady) return;
    const nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS || map[ny][nx] === 1) {
        playOscillator(150, 'square', 0.1);
    } else {
        player.x = nx; player.y = ny; currentSteps++;
        if (player.x === dog.x && player.y === dog.y) {
            playGameOverSound();
            setTimeout(() => { alert("イヌに捕まった！"); initGame(); }, 100);
            return;
        }
        if (map[ny][nx] === 2) {
            playOscillator(800, 'sine', 0.5);
            setTimeout(() => { alert("成功！"); initGame(); }, 100);
            return;
        }
        // 犬が隣にいたら音を出す
        if (Math.abs(player.x - dog.x) + Math.abs(player.y - dog.y) === 1) {
            playDogSound();
        }
    }
    distText.innerText = `歩数: ${currentSteps} / 最短: ${minDistance}`;
    draw();
}

function draw() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const size = Math.min(canvas.width / COLS, canvas.height / ROWS);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!isBlind) {
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                if (map[y][x] === 1) { ctx.fillStyle = "#ccc"; ctx.fillRect(x*size, y*size, size, size); }
                if (map[y][x] === 2) { ctx.fillStyle = "#f00"; ctx.fillRect(x*size, y*size, size, size); }
            }
        }
        ctx.fillStyle = '#22cc22'; ctx.beginPath(); ctx.arc(dog.x*size + size/2, dog.y*size + size/2, size/4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0077ff'; ctx.beginPath(); ctx.arc(player.x*size + size/2, player.y*size + size/2, size/3, 0, Math.PI*2); ctx.fill();
    } else {
        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

function initGame() {
    generateSimpleMaze();
    player = { x: 1, y: 1 };
    currentSteps = 0;
    draw();
}

let tsX = null, tsY = null;
window.addEventListener('touchstart', async (e) => {
    if (!soundReady) {
        await unlockAudio();
        startMsg.style.display = 'none';
    }
    tsX = e.touches[0].clientX; tsY = e.touches[0].clientY;
}, { passive: false });

window.addEventListener('touchend', e => {
    if (tsX === null || tsY === null) return;
    const dx = e.changedTouches[0].clientX - tsX, dy = e.changedTouches[0].clientY - tsY;
    if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
        if (Math.abs(dx) > Math.abs(dy)) movePlayer(dx > 0 ? 1 : -1, 0); else movePlayer(0, dy > 0 ? 1 : -1);
    }
    tsX = null; tsY = null;
}, { passive: false });

document.getElementById('toggleMode').onclick = (e) => {
    isBlind = !isBlind; modeText.innerText = isBlind ? "ブラインド" : "視界あり"; draw();
};
window.onload = initGame;
window.onresize = draw;
</script>
</body>
</html>
